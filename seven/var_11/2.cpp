#include <iostream>     // библиотека ввода-вывода C++
#include <time.h>       // библиотека, дающая доступ к системному времени
#include <cmath>        // библиотека, содержащяя функции математических операций

using namespace std;

/* Найти:
    1. Номер максимального по модулю элемента массива
    2. Сумму локальных максимумов массива
    3. Произведение элементов массива, расположенных между первым и последним отрицательными элементами
*/ 

int main() {

    // генерация случайного числа для функции rand()
    srand(time(0));

    // размер массива - константа
    const int SIZE = 10;

    // объявляем массив, элементы в нем - целые числа (int)
    int arr[SIZE];

    // инициализация массива, цикл с предусловием
    for (int i = 0; i < SIZE; i++) {
        // находим остаток от деления случайного числа на 21 (теперь число входит в [0; 20]) и вычитаем 10 из него (входит в [-10; 10])
        arr[i] = rand() % 21 - 10;                  // присваиваем только что сгенерированное число каждому элементу
    }

    // выводим получившийся массив
    cout << "Массив arr[" << SIZE << "] из случайных элементов:\n";
    for (int i = 0; i < SIZE; i++) {
        cout << "[" << arr[i] << "] ";              // [1] [2] [3] [...]
    }
    cout << "\n\n";                                 // дважды переходим на новую линию

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // находим максимальный по модулю элемент

    int mod_max = 0;                                // в этой переменной будет храниться номер максимального элемента массива, она сразу = 0
    for (int i = 0; i < SIZE; i++) {
        if (abs(arr[i]) > abs(arr[mod_max])) {      // если |элемент| > |максимальный элемент, известный на текущий момент|
            mod_max = i;                            // mod_max = место в массиве максимального элемента, известного на текущий момент
        }
    }
    // выводим это всё
    cout << "Максимальный по модулю элемент массива: arr[" << mod_max << "]\n";


    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // сумма локальных максимумов массива

    int local_max_sum = 0;                          // сумма локальных максимумов, целое число, изначально = 0                
    for (int i = 1; i < SIZE; i++) {
        // если этот элемент больше, чем его адрес + 1, и (&&) больше, чем адрес -1
        if (arr[i] > arr[i+1] && arr[i] > arr[i-1]) {
            local_max_sum += arr[i];                // то прибавляем его к сумме локальных максимумов
        }
    }
    // вывод
    cout << "Сумма локальных максимумов массива: " << local_max_sum << "\n";


    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // произведение элементов массива, расположенных между первым и последним отрицательными элементами
    int first_negative = 69;                        // адрес первого отрицательного элемента
    int last_negative;                              // адрес последнего отрицательного элемента
    int product = 1;                                // произведение элементов между отрицательными элементами, не должно быть = 0
    for (int i = 0; i < SIZE; i++) {
        if (arr[i] < 0 && first_negative == 69) {   // если элемент < 0 и first_negative все еще = 69
            first_negative = i;                     // first_negative = адресу первого отрицательного элемента 
        } else if (arr[i] < 0 && first_negative != 69) { // но если first_negative не равен 69
            last_negative = i;                      // то каждый раз обновляем адрес последнего отр. элемента, пока не дойдем до последнего
        }
    }
    // теперь перемножаем все, что между этими двумя отрицательными элементами
    for (int i = first_negative + 1; i < last_negative; i++) {
        product *= arr[i];
    }
    // вывод
    cout << "Произведение элементов массива, расположенных между первым и последним отрицательными элементами: " << product << "\n";
}
